import {
  collection,
  addDoc,
  query,
  where,
  orderBy,
  getDocs,
  doc,
  updateDoc,
  deleteDoc,
} from "firebase/firestore";
import { db } from "./firebase";
import OpenAI from "openai";
import moment from "moment";

const mockResponses = [
  "I'm a mock AI assistant. This is a development response to save your API credits.",
  "This is a placeholder response. In production, this would be generated by OpenAI's API.",
  "Hello! I'm a simulated response. In development mode to avoid rate limits.",
  "I'm here to help! This is a mock response to prevent hitting OpenAI API rate limits during development.",
  "Thanks for your message. This is a simulated response to help you test your application without using API credits.",
];

// Get a random response from the array
export function getMockResponse(): string {
  const randomIndex = Math.floor(Math.random() * mockResponses.length);
  return mockResponses[randomIndex];
}

// Set this to true to use mock responses instead of calling the OpenAI API
const USE_MOCK_RESPONSES = false;

const openai = new OpenAI({
  apiKey: process.env.NEXT_PUBLIC_OPENAI_API_KEY,
  dangerouslyAllowBrowser: true,
});

export interface Message {
  id?: string;
  role: "user" | "assistant";
  content: string;
  timestamp: Date;
}

export interface Chat {
  id?: string;
  userId: string;
  title: string;
  messages: Message[];
  createdAt: Date;
  updatedAt: Date;
}

export class ChatService {
  static async createChat(userId: string, title: string): Promise<string> {
    const chatData = {
      userId,
      title,
      messages: [],
      createdAt: moment().toDate(),
      updatedAt: moment().toDate(),
    };

    const docRef = await addDoc(collection(db, "chats"), chatData);
    return docRef.id;
  }

  static async getChats(userId: string): Promise<Chat[]> {
    const q = query(
      collection(db, "chats"),
      where("userId", "==", userId),
      orderBy("updatedAt", "desc")
    );

    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate() || moment().toDate(),
        updatedAt: data.updatedAt?.toDate() || moment().toDate(),
      } as Chat;
    });
  }

  static async addMessage(chatId: string, message: Message): Promise<void> {
    const chatRef = doc(db, "chats", chatId);
    const chat = await getDocs(
      query(collection(db, "chats"), where("__name__", "==", chatId))
    );

    if (!chat.empty) {
      const chatData = chat.docs[0].data() as Chat;
      const updatedMessages = [...chatData.messages, message];

      await updateDoc(chatRef, {
        messages: updatedMessages,
        updatedAt: moment().toDate(),
      });
    }
  }

  static async updateMessage(
    chatId: string,
    messageIndex: number,
    newContent: string
  ): Promise<void> {
    const chatRef = doc(db, "chats", chatId);
    const chat = await getDocs(
      query(collection(db, "chats"), where("__name__", "==", chatId))
    );

    if (!chat.empty) {
      const chatData = chat.docs[0].data() as Chat;
      const updatedMessages = [...chatData.messages];

      if (messageIndex >= 0 && messageIndex < updatedMessages.length) {
        updatedMessages[messageIndex] = {
          ...updatedMessages[messageIndex],
          content: newContent,
          timestamp: moment().toDate(),
        };

        await updateDoc(chatRef, {
          messages: updatedMessages,
          updatedAt: moment().toDate(),
        });
      }
    }
  }

  static async deleteMessage(
    chatId: string,
    messageIndex: number
  ): Promise<void> {
    const chatRef = doc(db, "chats", chatId);
    const chat = await getDocs(
      query(collection(db, "chats"), where("__name__", "==", chatId))
    );

    if (!chat.empty) {
      const chatData = chat.docs[0].data() as Chat;
      const updatedMessages = [...chatData.messages];

      if (messageIndex >= 0 && messageIndex < updatedMessages.length) {
        updatedMessages.splice(messageIndex, 1);

        await updateDoc(chatRef, {
          messages: updatedMessages,
          updatedAt: moment().toDate(),
        });
      }
    }
  }

  static async deleteChat(chatId: string): Promise<void> {
    const chatRef = doc(db, "chats", chatId);
    await deleteDoc(chatRef);
  }

  static async sendMessageToChatGPT(messages: Message[]): Promise<string> {
    try {
      if (USE_MOCK_RESPONSES) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        return getMockResponse();
      }

      // Otherwise use the real API
      const response = await openai.responses.create({
        model: "gpt-3.5-turbo",
        input: messages.map((msg) => ({
          role: msg.role,
          content: msg.content,
        })),
      });
      // const response = await openai.chat.completions.create({
      //   model: "gpt-3.5-turbo",
      //   messages: messages.map((msg) => ({
      //     role: msg.role,
      //     content: msg.content,
      //   })),
      //   max_tokens: 1000,
      //   temperature: 0.7,
      // });

      return response.output_text || "Sorry, I could not generate a response.";
    } catch (error) {
      console.error("Error calling ChatGPT API:", error);
      return "I'm currently unable to respond due to API limitations. Please try again later.";
    }
  }

  static async sendMessage(
    chatId: string,
    userId: string,
    userMessage: string
  ): Promise<string> {
    // Add user message to chat
    const userMsg: Message = {
      role: "user",
      content: userMessage,
      timestamp: new Date(),
    };

    await this.addMessage(chatId, userMsg);

    // Get all messages for context
    const chat = await getDocs(
      query(collection(db, "chats"), where("__name__", "==", chatId))
    );
    const chatData = chat.docs[0].data() as Chat;
    const allMessages = [...chatData.messages, userMsg];

    // Get response from ChatGPT
    const assistantResponse = await this.sendMessageToChatGPT(allMessages);

    // Add assistant message to chat
    const assistantMsg: Message = {
      role: "assistant",
      content: assistantResponse,
      timestamp: new Date(),
    };

    await this.addMessage(chatId, assistantMsg);

    return assistantResponse;
  }
}
